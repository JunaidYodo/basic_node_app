name: Deploy Next Hire Node APP

on:
  push:
    branches: dev
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: next-hire-app
  AWS_ACCOUNT_ID: 618166615317
  PORT: 3000

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    env:
      NODE_ENV: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

  determine-version:
    needs: lint-and-test
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    permissions:
      contents: write
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get next semantic version
      id: version
      run: |
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        VERSION=${LATEST_TAG#v}
        MAJOR=$(echo $VERSION | cut -d. -f1)
        MINOR=$(echo $VERSION | cut -d. -f2)
        PATCH=$(echo $VERSION | cut -d. -f3)
        
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="v$MAJOR.$MINOR.$NEW_PATCH"
        
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Create and push Git tag
        run: |
          NEW_VERSION="${{ steps.version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"

  build-and-push:
    needs: determine-version
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ needs.determine-version.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set version
        id: version
        run: |
          VERSION="${{ needs.determine-version.outputs.version }}"
          echo "image-tag=$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Build

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          build-args: |
            BUILD_VERSION=${{ steps.version.outputs.image-tag }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            COMMIT_SHA=${{ github.sha }}
          tags: |
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.image-tag }}
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest
          push: true

  deploy-to-dev:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Dev

      - name: Update ECS task definition with new image
        id: update-task-def
        run: |
          VERSION="${{ needs.build-and-push.outputs.image-tag }}"
          NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"

          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition next-hire-app-dev \
            --query 'taskDefinition' \
            --output json)

          NEW_TASK_DEF=$(echo $TASK_DEFINITION | jq \
            --arg IMAGE "$NEW_IMAGE" \
            --arg NODE_ENV "dev" \
            --arg PORT "$PORT" \
            '
            .containerDefinitions[0].image = $IMAGE |
            .containerDefinitions[0].environment = [
              {"name": "NODE_ENV", "value": $NODE_ENV},
              {"name": "PORT", "value": $PORT}
            ] |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
            ')

          NEW_TASK_INFO=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "task-definition-arn=$NEW_TASK_INFO" >> $GITHUB_OUTPUT

      - name: Deploy to Development
        run: |
          aws ecs update-service \
            --cluster next-hire-cluster-dev \
            --service next-hire-app-dev \
            --task-definition ${{ steps.update-task-def.outputs.task-definition-arn }} \
            --force-new-deployment

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster next-hire-cluster-dev \
            --services next-hire-app-dev

  deploy-to-staging:
    needs: deploy-to-dev
    if: success()
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Staging

      - name: Update ECS task definition with new image
        id: update-task-def-staging
        run: |
          VERSION="${{ needs.build-and-push.outputs.image-tag }}"
          NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"

          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition next-hire-app-staging \
            --query 'taskDefinition' \
            --output json)

          NEW_TASK_DEF=$(echo $TASK_DEFINITION | jq \
            --arg IMAGE "$NEW_IMAGE" \
            --arg NODE_ENV "staging" \
            --arg PORT "$PORT" \
            '
            .containerDefinitions[0].image = $IMAGE |
            .containerDefinitions[0].environment = [
              {"name": "NODE_ENV", "value": $NODE_ENV},
              {"name": "PORT", "value": $PORT}
            ] |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
            ')

          NEW_TASK_INFO=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "task-definition-arn=$NEW_TASK_INFO" >> $GITHUB_OUTPUT

      - name: Deploy to Staging
        run: |
          aws ecs update-service \
            --cluster next-hire-cluster-staging \
            --service next-hire-app-staging \
            --task-definition ${{ steps.update-task-def-staging.outputs.task-definition-arn }} \
            --force-new-deployment

      - name: Wait for Staging deployment
        run: |
          aws ecs wait services-stable \
            --cluster next-hire-cluster-staging \
            --services next-hire-app-staging
