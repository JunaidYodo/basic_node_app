name: Deploy Next Hire Node APP

on:
  push:
    branches: [ dev ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: next-hire-app
  AWS_ACCOUNT_ID: 618166615317
  PORT: 3000
  DEV_CLUSTER: next-hire-cluster-dev
  DEV_SERVICE: next-hire-app-dev
  SSM_IMAGE_TAG_PARAMETER: "/ecs/next-hire-app/dev/image-tag"

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    env:
      NODE_ENV: dev
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Lint code
      run: npm run lint

    - name: Run tests
      run: npm test

  determine-version:
    needs: lint-and-test
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    permissions:
      contents: write
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get next semantic version
      id: version
      run: |
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        VERSION=${LATEST_TAG#v}
        MAJOR=$(echo $VERSION | cut -d. -f1)
        MINOR=$(echo $VERSION | cut -d. -f2)
        PATCH=$(echo $VERSION | cut -d. -f3)
        
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="v$MAJOR.$MINOR.$NEW_PATCH"
        
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

    - name: Create and push Git tag
      run: |
        NEW_VERSION="${{ steps.version.outputs.version }}"
        echo "Creating Git tag: $NEW_VERSION"
        
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
        git push origin "$NEW_VERSION"
        
        echo "Tag $NEW_VERSION created and pushed"

  build-and-push:
    needs: determine-version
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.version.outputs.image-tag }}
    permissions:
      id-token: write
      contents: read
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set version
      id: version
      run: |
        VERSION="${{ needs.determine-version.outputs.version }}"
        echo "image-tag=$VERSION" >> $GITHUB_OUTPUT
        echo "Using image tag: $VERSION"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Build

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        build-args: |
          BUILD_VERSION=${{ steps.version.outputs.image-tag }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          COMMIT_SHA=${{ github.sha }}
        tags: |
          ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.image-tag }}
          ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest
        push: true

    - name: Logout from Amazon ECR
      if: always()
      run: docker logout ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

  deploy-to-dev:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: dev
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Dev

    - name: Update SSM Parameter with new image tag
      run: |
        VERSION="${{ needs.build-and-push.outputs.image-tag }}"
        echo "Updating SSM parameter $SSM_IMAGE_TAG_PARAMETER with version: $VERSION"
        
        # Update Parameter Store
        aws ssm put-parameter \
          --name "$SSM_IMAGE_TAG_PARAMETER" \
          --value "$VERSION" \
          --type "String" \
          --overwrite
        
        echo "SSM parameter updated successfully"

    - name: Get current task definition
      id: get-task
      run: |
        echo "Getting current task definition..."
        TASK_ARN=$(aws ecs describe-task-definition \
          --task-definition ${{ env.DEV_SERVICE }} \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "Current task definition: $TASK_ARN"
        echo "task-arn=$TASK_ARN" >> $GITHUB_OUTPUT

    - name: Force ECS service update
      run: |
        echo "Forcing ECS service deployment..."
        
        # Update service with existing task definition (force new deployment)
        aws ecs update-service \
          --cluster ${{ env.DEV_CLUSTER }} \
          --service ${{ env.DEV_SERVICE }} \
          --task-definition ${{ steps.get-task.outputs.task-arn }} \
          --force-new-deployment
        
        echo "ECS service update initiated"

    - name: Wait for deployment
      run: |
        echo "Waiting for deployment to stabilize..."
        
        # Wait for service to stabilize
        aws ecs wait services-stable \
          --cluster ${{ env.DEV_CLUSTER }} \
          --services ${{ env.DEV_SERVICE }}
        
        echo "Deployment completed successfully!"

    - name: Verify new image is running
      run: |
        echo "Verifying new image version..."
        sleep 10
        
        # Get current running tasks
        TASK_ARN=$(aws ecs list-tasks \
          --cluster ${{ env.DEV_CLUSTER }} \
          --service ${{ env.DEV_SERVICE }} \
          --query 'taskArns[0]' \
          --output text)
        
        if [ -n "$TASK_ARN" ] && [ "$TASK_ARN" != "None" ]; then
          echo "Found running task: $TASK_ARN"
          
          # Get task details
          TASK_DETAILS=$(aws ecs describe-tasks \
            --cluster ${{ env.DEV_CLUSTER }} \
            --tasks $TASK_ARN \
            --query 'tasks[0].containers[0].image' \
            --output text)
          
          echo "Current running image: $TASK_DETAILS"
          
          EXPECTED_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.build-and-push.outputs.image-tag }}"
          
          if [[ "$TASK_DETAILS" == *"${{ needs.build-and-push.outputs.image-tag }}"* ]]; then
            echo "✅ Success! New image version is running"
          else
            echo "⚠️ Warning: New image version not detected. Running: $TASK_DETAILS"
            echo "Expected tag: ${{ needs.build-and-push.outputs.image-tag }}"
          fi
        else
          echo "❌ Error: No running tasks found"
          exit 1
        fi

    - name: Health check
      run: |
        echo "Performing health check..."
        
        # Get ALB DNS name
        ALB_NAME="next-hire-alb-dev"
        
        # Wait a bit for service to be fully ready
        sleep 30
        
        # Try to get ALB DNS
        SERVICE_URL=$(aws elbv2 describe-load-balancers \
          --names "$ALB_NAME" \
          --query 'LoadBalancers[0].DNSName' \
          --output text 2>/dev/null || echo "")
        
        if [ -n "$SERVICE_URL" ]; then
          echo "Checking health at: http://$SERVICE_URL/health"
          
          # Try multiple times with exponential backoff
          for i in {1..5}; do
            echo "Health check attempt $i..."
            if curl -s -f --max-time 10 "http://$SERVICE_URL/health"; then
              echo "✅ Health check passed!"
              exit 0
            fi
            echo "Attempt $i failed, waiting $((i * 10)) seconds..."
            sleep $((i * 10))
          done
          
          echo "❌ Health check failed after multiple attempts"
          echo "Last known service URL: http://$SERVICE_URL"
          exit 1
        else
          echo "⚠️ Could not get ALB URL, checking ECS service status..."
          
          # Check ECS service directly
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.DEV_CLUSTER }} \
            --services ${{ env.DEV_SERVICE }} \
            --query 'services[0]')
          
          RUNNING_COUNT=$(echo $SERVICE_STATUS | jq -r '.runningCount')
          DESIRED_COUNT=$(echo $SERVICE_STATUS | jq -r '.desiredCount')
          
          if [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ]; then
            echo "✅ ECS service is healthy: $RUNNING_COUNT/$DESIRED_COUNT tasks running"
            exit 0
          else
            echo "❌ ECS service unhealthy: $RUNNING_COUNT/$DESIRED_COUNT tasks running"
            exit 1
          fi
        fi

  rollback-on-failure:
    needs: deploy-to-dev
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Rollback

      - name: Rollback to previous SSM parameter value
        run: |
          echo "Rolling back due to deployment failure..."
          
          # Try to get previous value from SSM parameter history
          PREVIOUS_VALUE=$(aws ssm get-parameter-history \
            --name "$SSM_IMAGE_TAG_PARAMETER" \
            --query 'Parameters[?Version==`1`].Value' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$PREVIOUS_VALUE" ]; then
            echo "Rolling back to previous version: $PREVIOUS_VALUE"
            
            aws ssm put-parameter \
              --name "$SSM_IMAGE_TAG_PARAMETER" \
              --value "$PREVIOUS_VALUE" \
              --type "String" \
              --overwrite
            
            echo "Rolled back SSM parameter"
          else
            echo "Could not find previous SSM parameter value"
          fi
          
          # Force another deployment to use previous image
          aws ecs update-service \
            --cluster ${{ env.DEV_CLUSTER }} \
            --service ${{ env.DEV_SERVICE }} \
            --force-new-deployment

  notification:
    needs: [deploy-to-dev, rollback-on-failure]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Send deployment notification
        if: always()
        run: |
          DEPLOY_STATUS="${{ needs.deploy-to-dev.result }}"
          ROLLBACK_STATUS="${{ needs.rollback-on-failure.result }}"
          
          if [ "$DEPLOY_STATUS" = "success" ]; then
            echo "✅ Dev deployment completed successfully!"
            echo "Image version: ${{ needs.build-and-push.outputs.image-tag }}"
          elif [ "$DEPLOY_STATUS" = "failure" ] && [ "$ROLLBACK_STATUS" = "success" ]; then
            echo "⚠️ Dev deployment failed but rollback succeeded"
          elif [ "$DEPLOY_STATUS" = "failure" ]; then
            echo "❌ Dev deployment failed!"
            exit 1
          elif [ "$DEPLOY_STATUS" = "cancelled" ]; then
            echo "⏸️ Dev deployment was cancelled"
          else
            echo "❓ Unknown deployment status: $DEPLOY_STATUS"
            exit 1
          fi