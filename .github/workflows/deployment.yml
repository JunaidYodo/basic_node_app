name: Deploy Next Hire Node APP

on:
  push:
    branches: [ dev ]
  workflow_dispatch:

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: next-hire-app
  AWS_ACCOUNT_ID: 618166615317
  PORT: 3000

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    env:
      NODE_ENV: dev
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: package-lock.json

    - name: Cache node modules
      uses: actions/cache@v3
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install dependencies
      run: |
        npm ci
        npm install prisma@7.1.0 @prisma/client@7.1.0
        npx prisma generate

    - name: Setup dev environment variables
      run: |
        echo "DATABASE_URL=postgresql://nexthireadmin:${{ secrets.DB_PASSWORD_DEV }}@{{secrets.DB_HOST_DEV}}:5432/nexthiredb" >> $GITHUB_ENV
        echo "NODE_ENV=dev" >> $GITHUB_ENV
        echo "PORT=3001" >> $GITHUB_ENV

    # - name: Wait for PostgreSQL to be ready
    #   run: |
    #     for i in $(seq 1 30); do
    #       if pg_isready --host="next-hire-db-dev.cluster-cxk440ioa00s.us-east-2.rds.amazonaws.com" --port=5432 --username="nexthireadmin"; then
    #         echo "PostgreSQL is ready"
    #         break
    #       fi
    #       echo "Waiting for PostgreSQL... ($i/30)"
    #       sleep 2
    #     done

    # - name: Run database migrations for tests
    #   env:
    #     DATABASE_URL: ${{ env.DATABASE_URL }}
    #   run: |
    #     npx prisma migrate deploy

    - name: Run ESLint
      run: |
        npm run lint || echo "ESLint check completed"

    - name: Run TypeScript compiler check
      run: |
        npx tsc --noEmit || echo "TypeScript check completed"

    # - name: Run tests with coverage
    #   env:
    #     DATABASE_URL: ${{ env.DATABASE_URL }}
    #     JWT_SECRET: ${{ env.JWT_SECRET }}
    #     NODE_ENV: ${{ env.NODE_ENV }}
    #     PORT: ${{ env.PORT }}
    #   run: |
    #     npm test -- --coverage

    - name: Security scan with npm audit
      run: |
        npm audit --audit-level=high
      continue-on-error: true

    - name: Run Trivy vulnerability scanner on source code
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-fs-results.sarif'
        severity: 'CRITICAL,HIGH'

  determine-version:
    needs: lint-and-test
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    permissions:
      contents: write
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get next semantic version
      id: version
      run: |
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        VERSION=${LATEST_TAG#v}
        MAJOR=$(echo $VERSION | cut -d. -f1)
        MINOR=$(echo $VERSION | cut -d. -f2)
        PATCH=$(echo $VERSION | cut -d. -f3)
        
        NEW_PATCH=$((PATCH + 1))
        NEW_VERSION="v$MAJOR.$MINOR.$NEW_PATCH"
        
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

    - name: Create and push Git tag
      run: |
        NEW_VERSION="${{ steps.version.outputs.version }}"
        echo "Creating Git tag: $NEW_VERSION"
        
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
        git push origin "$NEW_VERSION"
        
        echo "Tag $NEW_VERSION created and pushed"

  build-and-push:
    needs: determine-version
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ needs.determine-version.outputs.version }}
    permissions:
      id-token: write
      contents: read
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set version
      id: version
      run: |
        VERSION="${{ needs.determine-version.outputs.version }}"
        echo "image-tag=$VERSION" >> $GITHUB_OUTPUT
        echo "Using image tag: $VERSION"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Build

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        build-args: |
          BUILD_VERSION=${{ steps.version.outputs.image-tag }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          COMMIT_SHA=${{ github.sha }}
        tags: |
          ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.image-tag }}
          ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest
        push: true

    - name: Run Trivy vulnerability scanner on Docker image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.image-tag }}
        format: 'sarif'
        output: 'trivy-image-results.sarif'
        severity: 'CRITICAL,HIGH'

  deploy-to-dev:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: 
      name: dev
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Dev

    - name: Create DATABASE_URL for development
      run: |
        DB_HOST="${{ secrets.DB_HOST_DEV }}"
        DB_PORT="${{ secrets.DB_PORT_DEV }}"
        DB_NAME="${{ secrets.DB_NAME_DEV }}"
        DB_USERNAME="${{ secrets.DB_USERNAME_DEV }}"
        DB_PASSWORD="${{ secrets.DB_PASSWORD_DEV }}"
        
        # Create DATABASE_URL
        DATABASE_URL="postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT/$DB_NAME"
        
        echo "DATABASE_URL=$DATABASE_URL" >> $GITHUB_ENV
        echo "DB_HOST=$DB_HOST" >> $GITHUB_ENV
        echo "DB_PORT=$DB_PORT" >> $GITHUB_ENV
        echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV
        echo "DB_USERNAME=$DB_USERNAME" >> $GITHUB_ENV

    - name: Update task definition with new image and secrets
      id: update-task-def
      env:
        DATABASE_URL: ${{ env.DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET_DEV }}
        NODE_ENV: production
        PORT: ${{ env.PORT }}
      run: |
        VERSION="${{ needs.build-and-push.outputs.image-tag }}"
        NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"
        
        echo "Updating task definition with image: $NEW_IMAGE"
        
        # Get current task definition
        TASK_DEFINITION=$(aws ecs describe-task-definition \
          --task-definition next-hire-app-dev \
          --query 'taskDefinition' \
          --output json)
        
        # Update the image and environment variables
        NEW_TASK_DEF=$(echo $TASK_DEFINITION | jq \
          --arg IMAGE "$NEW_IMAGE" \
          --arg DATABASE_URL "$DATABASE_URL" \
          --arg NODE_ENV "$NODE_ENV" \
          --arg PORT "$PORT" \
          '
          .containerDefinitions[0].image = $IMAGE |
          .containerDefinitions[0].environment = [
            {"name": "DATABASE_URL", "value": $DATABASE_URL},
            {"name": "NODE_ENV", "value": $NODE_ENV},
            {"name": "PORT", "value": $PORT}
          ] |
          del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ')
        
        # Register new task definition
        NEW_TASK_INFO=$(aws ecs register-task-definition \
          --cli-input-json "$NEW_TASK_DEF" \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "New task definition registered: $NEW_TASK_INFO"
        echo "task-definition-arn=$NEW_TASK_INFO" >> $GITHUB_OUTPUT

    - name: Run database migrations via SSM Session
      env:
        DATABASE_URL: ${{ env.DATABASE_URL }}
        IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
      run: |
        echo "Running database migrations via SSM..."
        
        # Find an ECS task that's running
        TASK_ARN=$(aws ecs list-tasks \
          --cluster next-hire-cluster-dev \
          --service next-hire-app-dev \
          --query 'taskArns[0]' \
          --output text)
        
        if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" = "None" ]; then
          echo "No running tasks found. Starting a new task for migrations..."
          
          # Start a one-off task for migrations
          TASK_ARN=$(aws ecs run-task \
            --cluster next-hire-cluster-dev \
            --task-definition next-hire-app-dev \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ secrets.SUBNET_IDS_DEV }}],securityGroups=[${{ secrets.SECURITY_GROUP_IDS_DEV }}],assignPublicIp=DISABLED}" \
            --overrides '{"containerOverrides":[{"name":"next-hire","command":["npx","prisma","migrate","deploy"],"environment":[{"name":"DATABASE_URL","value":"'"$DATABASE_URL"'"}]}]}' \
            --query 'tasks[0].taskArn' \
            --output text)
          
          # Wait for task to complete
          echo "Waiting for migration task to complete..."
          aws ecs wait tasks-stopped \
            --cluster next-hire-cluster-dev \
            --tasks $TASK_ARN
            
          # Check exit code
          TASK_STATUS=$(aws ecs describe-tasks \
            --cluster next-hire-cluster-dev \
            --tasks $TASK_ARN \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)
          
          if [ "$TASK_STATUS" != "0" ]; then
            echo "Migration task failed with exit code: $TASK_STATUS"
            exit 1
          fi
          
          echo "Migrations completed via one-off ECS task"
        else
          echo "Found running task: $TASK_ARN"
          echo "Running migrations via exec command..."
          
          # Get the task ID
          TASK_ID=$(echo $TASK_ARN | cut -d'/' -f3)
          
          # Run migrations via ECS exec
          aws ecs execute-command \
            --cluster next-hire-cluster-dev \
            --task $TASK_ID \
            --container next-hire \
            --interactive \
            --command "npx prisma migrate deploy"
          
          echo "Migrations completed via ECS exec"
        fi

    - name: Deploy to Development
      run: |
        VERSION="${{ needs.build-and-push.outputs.image-tag }}"
        echo "Deploying version $VERSION to Development"
        
        # Update service with new task definition
        aws ecs update-service \
          --cluster next-hire-cluster-dev \
          --service next-hire-app-dev \
          --task-definition ${{ steps.update-task-def.outputs.task-definition-arn }} \
          --force-new-deployment

    - name: Wait for deployment
      run: |
        echo "Waiting for Development deployment to stabilize..."
        aws ecs wait services-stable \
          --cluster next-hire-cluster-dev \
          --services next-hire-app-dev
        echo "Development deployment completed successfully!"

    - name: Health check
      run: |
        echo "Performing health check..."
        MAX_RETRIES=30
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          SERVICE_URL=$(aws elbv2 describe-load-balancers --names next-hire-alb-dev --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")
          
          if [ -n "$SERVICE_URL" ]; then
            if curl -f -s -o /dev/null -w "%{http_code}" http://$SERVICE_URL/health | grep -q "200"; then
              echo "Health check passed!"
              exit 0
            fi
          fi
          
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "Health check attempt $RETRY_COUNT failed. Retrying in 10 seconds..."
          sleep 10
        done
        
        echo "Health check failed after $MAX_RETRIES attempts"
        exit 1


  deploy-to-staging:
    needs: [build-and-push, deploy-to-dev]
    if: success()
    runs-on: ubuntu-latest
    environment: 
      name: staging
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
        aws-region: ${{ env.AWS_REGION }}
        role-session-name: GitHubActions-Staging

    - name: Create DATABASE_URL for staging
      run: |
        DB_HOST="${{ secrets.DB_HOST_STAGING }}"
        DB_PORT="${{ secrets.DB_PORT_STAGING }}"
        DB_NAME="${{ secrets.DB_NAME_STAGING }}"
        DB_USERNAME="${{ secrets.DB_USERNAME_STAGING }}"
        DB_PASSWORD="${{ secrets.DB_PASSWORD_STAGING }}"
        
        # Create DATABASE_URL
        DATABASE_URL="postgresql://$DB_USERNAME:$DB_PASSWORD@$DB_HOST:$DB_PORT/$DB_NAME"
        
        echo "DATABASE_URL=$DATABASE_URL" >> $GITHUB_ENV
        echo "DB_HOST=$DB_HOST" >> $GITHUB_ENV
        echo "DB_PORT=$DB_PORT" >> $GITHUB_ENV
        echo "DB_NAME=$DB_NAME" >> $GITHUB_ENV
        echo "DB_USERNAME=$DB_USERNAME" >> $GITHUB_ENV

    - name: Update staging task definition
      id: update-staging-task-def
      env:
        DATABASE_URL: ${{ env.DATABASE_URL }}
        JWT_SECRET: ${{ secrets.JWT_SECRET_STAGING }}
        NODE_ENV: staging
        PORT: ${{ env.PORT }}
      run: |
        VERSION="${{ needs.build-and-push.outputs.image-tag }}"
        NEW_IMAGE="${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$VERSION"
        
        echo "Updating staging task definition with image: $NEW_IMAGE"
        
        # Get current task definition
        TASK_DEFINITION=$(aws ecs describe-task-definition \
          --task-definition next-hire-app-staging \
          --query 'taskDefinition' \
          --output json)
        
        # Update the image and environment variables
        NEW_TASK_DEF=$(echo $TASK_DEFINITION | jq \
          --arg IMAGE "$NEW_IMAGE" \
          --arg DATABASE_URL "$DATABASE_URL" \
          --arg NODE_ENV "$NODE_ENV" \
          --arg PORT "$PORT" \
          '
          .containerDefinitions[0].image = $IMAGE |
          .containerDefinitions[0].environment = [
            {"name": "DATABASE_URL", "value": $DATABASE_URL},
            {"name": "NODE_ENV", "value": $NODE_ENV},
            {"name": "PORT", "value": $PORT}
          ] |
          del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ')
        
        # Register new task definition
        NEW_TASK_INFO=$(aws ecs register-task-definition \
          --cli-input-json "$NEW_TASK_DEF" \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "New task definition registered: $NEW_TASK_INFO"
        echo "task-definition-arn=$NEW_TASK_INFO" >> $GITHUB_OUTPUT

    - name: Run database migrations for staging
      env:
        DATABASE_URL: ${{ env.DATABASE_URL }}
      run: |
        echo "Running database migrations for staging..."
        docker run --rm \
          -e DATABASE_URL="$DATABASE_URL" \
          ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.build-and-push.outputs.image-tag }} \
          npx prisma migrate deploy

    - name: Deploy to Staging
      run: |
        VERSION="${{ needs.build-and-push.outputs.image-tag }}"
        echo "Deploying version $VERSION to Staging"
        
        aws ecs update-service \
          --cluster next-hire-cluster-staging \
          --service next-hire-app-staging \
          --task-definition ${{ steps.update-staging-task-def.outputs.task-definition-arn }} \
          --force-new-deployment

    - name: Wait for staging deployment
      run: |
        echo "Waiting for Staging deployment..."
        aws ecs wait services-stable \
          --cluster next-hire-cluster-staging \
          --services next-hire-app-staging
        echo "Staging deployment completed!"

    - name: Run staging health check
      run: |
        echo "Performing staging health check..."
        SERVICE_URL=$(aws elbv2 describe-load-balancers --names next-hire-alb-staging --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")
        
        if [ -n "$SERVICE_URL" ]; then
          curl -f http://$SERVICE_URL/health || exit 1
          echo "Staging health check passed!"
        else
          echo "Could not get staging ALB URL"
          exit 1
        fi

  notification:
    needs: [deploy-to-dev, deploy-to-staging]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Send deployment notification
        if: always()
        run: |
          echo "Deployment completed!"
          # Add your notification logic here (Slack, Teams, Email, etc.)
          echo "Status: ${{ needs.deploy-to-staging.result || needs.deploy-to-dev.result }}"